// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CLIENT_CLIENTENCODER_H_
#define FLATBUFFERS_GENERATED_CLIENT_CLIENTENCODER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
                  FLATBUFFERS_VERSION_MINOR == 5 &&
                  FLATBUFFERS_VERSION_REVISION == 26,
              "Non-compatible flatbuffers version included");

namespace ClientEncoder
{

  struct Person;
  struct PersonBuilder;

  struct Group;
  struct GroupBuilder;

  struct Client;
  struct ClientBuilder;

  struct ClientContainer;
  struct ClientContainerBuilder;

  //***************** User defined functions****************************************************************************************
  // const ClientEncoder::Person *GetPerson(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ClientEncoder::Person> offset)
  // {
  //   return flatbuffers::GetTemporaryPointer<ClientEncoder::Person>(fbb, offset);
  // }

  // const ClientEncoder::Group *GetGroup(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ClientEncoder::Group> offset)
  // {
  //   return flatbuffers::GetTemporaryPointer<ClientEncoder::Group>(fbb, offset);
  // }
  //***********************************************************************************************************************************

  enum ClientUnion : uint8_t
  {
    ClientUnion_NONE = 0,
    ClientUnion_Person = 1,
    ClientUnion_Group = 2,
    ClientUnion_MIN = ClientUnion_NONE,
    ClientUnion_MAX = ClientUnion_Group
  };

  inline const ClientUnion (&EnumValuesClientUnion())[3]
  {
    static const ClientUnion values[] = {
        ClientUnion_NONE,
        ClientUnion_Person,
        ClientUnion_Group};
    return values;
  }

  inline const char *const *EnumNamesClientUnion()
  {
    static const char *const names[4] = {
        "NONE",
        "Person",
        "Group",
        nullptr};
    return names;
  }

  inline const char *EnumNameClientUnion(ClientUnion e)
  {
    if (::flatbuffers::IsOutRange(e, ClientUnion_NONE, ClientUnion_Group))
      return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesClientUnion()[index];
  }

  template <typename T>
  struct ClientUnionTraits
  {
    static const ClientUnion enum_value = ClientUnion_NONE;
  };

  template <>
  struct ClientUnionTraits<ClientEncoder::Person>
  {
    static const ClientUnion enum_value = ClientUnion_Person;
  };

  template <>
  struct ClientUnionTraits<ClientEncoder::Group>
  {
    static const ClientUnion enum_value = ClientUnion_Group;
  };

  bool VerifyClientUnion(::flatbuffers::Verifier &verifier, const void *obj, ClientUnion type);
  bool VerifyClientUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

  struct Person FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef PersonBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_NAME = 4,
      VT_AGE = 6,
      VT_WEIGHT = 8,
      VT_GENDER = 10
    };
    const ::flatbuffers::String *name() const
    {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    float age() const
    {
      return GetField<float>(VT_AGE, 0.0f);
    }
    float weight() const
    {
      return GetField<float>(VT_WEIGHT, 0.0f);
    }
    const ::flatbuffers::String *gender() const
    {
      return GetPointer<const ::flatbuffers::String *>(VT_GENDER);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyOffset(verifier, VT_NAME) &&
             verifier.VerifyString(name()) &&
             VerifyField<float>(verifier, VT_AGE, 4) &&
             VerifyField<float>(verifier, VT_WEIGHT, 4) &&
             VerifyOffset(verifier, VT_GENDER) &&
             verifier.VerifyString(gender()) &&
             verifier.EndTable();
    }
  };

  struct PersonBuilder
  {
    typedef Person Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
      fbb_.AddOffset(Person::VT_NAME, name);
    }
    void add_age(float age)
    {
      fbb_.AddElement<float>(Person::VT_AGE, age, 0.0f);
    }
    void add_weight(float weight)
    {
      fbb_.AddElement<float>(Person::VT_WEIGHT, weight, 0.0f);
    }
    void add_gender(::flatbuffers::Offset<::flatbuffers::String> gender)
    {
      fbb_.AddOffset(Person::VT_GENDER, gender);
    }
    explicit PersonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Person> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Person>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Person> CreatePerson(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      ::flatbuffers::Offset<::flatbuffers::String> name = 0,
      float age = 0.0f,
      float weight = 0.0f,
      ::flatbuffers::Offset<::flatbuffers::String> gender = 0)
  {
    PersonBuilder builder_(_fbb);
    builder_.add_gender(gender);
    builder_.add_weight(weight);
    builder_.add_age(age);
    builder_.add_name(name);
    return builder_.Finish();
  }

  inline ::flatbuffers::Offset<Person> CreatePersonDirect(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      const char *name = nullptr,
      float age = 0.0f,
      float weight = 0.0f,
      const char *gender = nullptr)
  {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    auto gender__ = gender ? _fbb.CreateString(gender) : 0;
    return ClientEncoder::CreatePerson(
        _fbb,
        name__,
        age,
        weight,
        gender__);
  }

  struct Group FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef GroupBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_GROUPNAME = 4,
      VT_AVERAGEAGE = 6,
      VT_AVERAGEWEIGHT = 8,
      VT_MEMBERS = 10
    };
    const ::flatbuffers::String *groupName() const
    {
      return GetPointer<const ::flatbuffers::String *>(VT_GROUPNAME);
    }
    float averageAge() const
    {
      return GetField<float>(VT_AVERAGEAGE, 0.0f);
    }
    float averageWeight() const
    {
      return GetField<float>(VT_AVERAGEWEIGHT, 0.0f);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Person>> *members() const
    {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Person>> *>(VT_MEMBERS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyOffset(verifier, VT_GROUPNAME) &&
             verifier.VerifyString(groupName()) &&
             VerifyField<float>(verifier, VT_AVERAGEAGE, 4) &&
             VerifyField<float>(verifier, VT_AVERAGEWEIGHT, 4) &&
             VerifyOffset(verifier, VT_MEMBERS) &&
             verifier.VerifyVector(members()) &&
             verifier.VerifyVectorOfTables(members()) &&
             verifier.EndTable();
    }
  };

  struct GroupBuilder
  {
    typedef Group Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_groupName(::flatbuffers::Offset<::flatbuffers::String> groupName)
    {
      fbb_.AddOffset(Group::VT_GROUPNAME, groupName);
    }
    void add_averageAge(float averageAge)
    {
      fbb_.AddElement<float>(Group::VT_AVERAGEAGE, averageAge, 0.0f);
    }
    void add_averageWeight(float averageWeight)
    {
      fbb_.AddElement<float>(Group::VT_AVERAGEWEIGHT, averageWeight, 0.0f);
    }
    void add_members(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Person>>> members)
    {
      fbb_.AddOffset(Group::VT_MEMBERS, members);
    }
    explicit GroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Group> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Group>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Group> CreateGroup(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      ::flatbuffers::Offset<::flatbuffers::String> groupName = 0,
      float averageAge = 0.0f,
      float averageWeight = 0.0f,
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Person>>> members = 0)
  {
    GroupBuilder builder_(_fbb);
    builder_.add_members(members);
    builder_.add_averageWeight(averageWeight);
    builder_.add_averageAge(averageAge);
    builder_.add_groupName(groupName);
    return builder_.Finish();
  }

  inline ::flatbuffers::Offset<Group> CreateGroupDirect(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      const char *groupName = nullptr,
      float averageAge = 0.0f,
      float averageWeight = 0.0f,
      const std::vector<::flatbuffers::Offset<ClientEncoder::Person>> *members = nullptr)
  {
    auto groupName__ = groupName ? _fbb.CreateString(groupName) : 0;
    auto members__ = members ? _fbb.CreateVector<::flatbuffers::Offset<ClientEncoder::Person>>(*members) : 0;
    return ClientEncoder::CreateGroup(
        _fbb,
        groupName__,
        averageAge,
        averageWeight,
        members__);
  }

  struct Client FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef ClientBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_CLIENT_TYPE = 4,
      VT_CLIENT = 6
    };
    ClientEncoder::ClientUnion client_type() const
    {
      return static_cast<ClientEncoder::ClientUnion>(GetField<uint8_t>(VT_CLIENT_TYPE, 0));
    }
    const void *client() const
    {
      return GetPointer<const void *>(VT_CLIENT);
    }
    template <typename T>
    const T *client_as() const;
    const ClientEncoder::Person *client_as_Person() const
    {
      return client_type() == ClientEncoder::ClientUnion_Person ? static_cast<const ClientEncoder::Person *>(client()) : nullptr;
    }
    const ClientEncoder::Group *client_as_Group() const
    {
      return client_type() == ClientEncoder::ClientUnion_Group ? static_cast<const ClientEncoder::Group *>(client()) : nullptr;
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyField<uint8_t>(verifier, VT_CLIENT_TYPE, 1) &&
             VerifyOffset(verifier, VT_CLIENT) &&
             VerifyClientUnion(verifier, client(), client_type()) &&
             verifier.EndTable();
    }
  };

  template <>
  inline const ClientEncoder::Person *Client::client_as<ClientEncoder::Person>() const
  {
    return client_as_Person();
  }

  template <>
  inline const ClientEncoder::Group *Client::client_as<ClientEncoder::Group>() const
  {
    return client_as_Group();
  }

  struct ClientBuilder
  {
    typedef Client Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_client_type(ClientEncoder::ClientUnion client_type)
    {
      fbb_.AddElement<uint8_t>(Client::VT_CLIENT_TYPE, static_cast<uint8_t>(client_type), 0);
    }
    void add_client(::flatbuffers::Offset<void> client)
    {
      fbb_.AddOffset(Client::VT_CLIENT, client);
    }
    explicit ClientBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Client> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Client>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Client> CreateClient(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      ClientEncoder::ClientUnion client_type = ClientEncoder::ClientUnion_NONE,
      ::flatbuffers::Offset<void> client = 0)
  {
    ClientBuilder builder_(_fbb);
    builder_.add_client(client);
    builder_.add_client_type(client_type);
    return builder_.Finish();
  }

  struct ClientContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef ClientContainerBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_CLIENTS = 4
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Client>> *clients() const
    {
      return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Client>> *>(VT_CLIENTS);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyOffset(verifier, VT_CLIENTS) &&
             verifier.VerifyVector(clients()) &&
             verifier.VerifyVectorOfTables(clients()) &&
             verifier.EndTable();
    }
  };

  struct ClientContainerBuilder
  {
    typedef ClientContainer Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_clients(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Client>>> clients)
    {
      fbb_.AddOffset(ClientContainer::VT_CLIENTS, clients);
    }
    explicit ClientContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ClientContainer> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<ClientContainer>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<ClientContainer> CreateClientContainer(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ClientEncoder::Client>>> clients = 0)
  {
    ClientContainerBuilder builder_(_fbb);
    builder_.add_clients(clients);
    return builder_.Finish();
  }

  inline ::flatbuffers::Offset<ClientContainer> CreateClientContainerDirect(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      const std::vector<::flatbuffers::Offset<ClientEncoder::Client>> *clients = nullptr)
  {
    auto clients__ = clients ? _fbb.CreateVector<::flatbuffers::Offset<ClientEncoder::Client>>(*clients) : 0;
    return ClientEncoder::CreateClientContainer(
        _fbb,
        clients__);
  }

  inline bool VerifyClientUnion(::flatbuffers::Verifier &verifier, const void *obj, ClientUnion type)
  {
    switch (type)
    {
    case ClientUnion_NONE:
    {
      return true;
    }
    case ClientUnion_Person:
    {
      auto ptr = reinterpret_cast<const ClientEncoder::Person *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientUnion_Group:
    {
      auto ptr = reinterpret_cast<const ClientEncoder::Group *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
    }
  }

  inline bool VerifyClientUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types)
  {
    if (!values || !types)
      return !values && !types;
    if (values->size() != types->size())
      return false;
    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
      if (!VerifyClientUnion(
              verifier, values->Get(i), types->GetEnum<ClientUnion>(i)))
      {
        return false;
      }
    }
    return true;
  }

  inline const ClientEncoder::ClientContainer *GetClientContainer(const void *buf)
  {
    return ::flatbuffers::GetRoot<ClientEncoder::ClientContainer>(buf);
  }

  inline const ClientEncoder::ClientContainer *GetSizePrefixedClientContainer(const void *buf)
  {
    return ::flatbuffers::GetSizePrefixedRoot<ClientEncoder::ClientContainer>(buf);
  }

  inline bool VerifyClientContainerBuffer(
      ::flatbuffers::Verifier &verifier)
  {
    return verifier.VerifyBuffer<ClientEncoder::ClientContainer>(nullptr);
  }

  inline bool VerifySizePrefixedClientContainerBuffer(
      ::flatbuffers::Verifier &verifier)
  {
    return verifier.VerifySizePrefixedBuffer<ClientEncoder::ClientContainer>(nullptr);
  }

  inline void FinishClientContainerBuffer(
      ::flatbuffers::FlatBufferBuilder &fbb,
      ::flatbuffers::Offset<ClientEncoder::ClientContainer> root)
  {
    fbb.Finish(root);
  }

  inline void FinishSizePrefixedClientContainerBuffer(
      ::flatbuffers::FlatBufferBuilder &fbb,
      ::flatbuffers::Offset<ClientEncoder::ClientContainer> root)
  {
    fbb.FinishSizePrefixed(root);
  }

} // namespace ClientEncoder

#endif // FLATBUFFERS_GENERATED_CLIENT_CLIENTENCODER_H_
